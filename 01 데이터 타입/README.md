## 1. 데이터 타입의 종류

> 자바스크립트의 데이터 타입은 **기본형**(원시형)과 **참조형**이 있다.

![](https://velog.velcdn.com/images/skdbsqls/post/da7051e5-9bc3-40d6-8f37-2afbb747273c/image.png)


일반적으로 기본형은 할당이나 연산 시 복제되고 참조형은 참조된다고 알려져 있으나, 엄밀히 말하면 둘 모두 복제를 하긴 한다. 다만 **기본형은 값이 담김 주솟값을 바로 복제하는 반면 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다**는 점이 다르다.

## 2. 데이터 타입에 관한 배경지식

### 메모리와 데이터

- **비트(Bit)**: 0 또는 1만 표현할 수 있는 하나의 메모리 조각을 비트라고 한다. 메모리는 매우 많은 비트들로 구성되어 있는데, 각 비트는 고유한 식별자를 통해 위치를 확인할 수 있다.

- **바이트(Byte)**: 매우 많은 비트를 한 단위로 묶으면 검색 시간을 줄일 수 있고 표현할 수 있는 데이터의 개수도 늘어나지만 동시에 낭비되는 비트가 생기기도 한다. 자주 사용하지 않을 데이터를 표현하기 위해 빈 공간을 남겨놓기보다는 표현 가능한 개수에 어느 정도 제약이 따르더라도 크게 문제가 되지 않을 적정한 공간을 묶는 편이 낫다. 이러한 고민의 결과 바이트라는 단위가 생겼다. 1바이트는 8개의 비트로 구성되어 있다.

> 비트는 고유한 식별자를 지니고, 바이트 역시 시작하는 비트의 식별자로 위치를 파악할 수 있다. **모든 데이터는 바이트 단위의 식별자, 메모리 주솟값을 통해 서로 구분하고 연결할 수 있다.**

### 식별자와 변수

- **변수**: 변할 수 있는 데이터를 말한다.
- **식별자**: 어떤 데이터를 식별하는 데 사용하는 이름, 즉 변수명을 말한다.

## 3. 변수 선언과 데이터 할당

### 변수 선언
```javascript
var a;
```

이를 말로 풀어쓰면 " 변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다."가 된다. 
**결국 변수란 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇이라고 할 수 있다.**

### 데이터 할당
```javascript
var a; // 변수 a 선언
a = 'abc'; // 변수 a에 데이터 할당

var a = 'abc'; // 변수 선언과 할당을 한 문장으로 표현
```
이는 데이터 할당 과정이다. a라는 이름을 가진 주소를 검색해서 그곳에 문자열 'abc'를 할당하면 될 것 같지만, 실제로는 해당 위치에 문자열 'abc'를 직접 저장하지는 않는다.

![](https://velog.velcdn.com/images/skdbsqls/post/37e814f2-b01a-4988-8f8d-41109b843646/image.png)

**데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 'abc'를 저장하고, 그 주소를 변수 영역에 저장하는 식으로 이루어진다.**

### ❓ 왜 변수 영역에 값을 직접 대입하지 않고 굳이 번거롭게 한 단계를 더 거치는 걸까?

- 미리 확보한 공간 내에서만 데이터를 변환할 수 있다면 변환한 데이터를 다시 저장 하기 위해 '확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'이 필요하다. 해당 공간이 메모리상의 가장 마지막에 있었다면 뒤쪽으로 늘리기만 하면 되지만, 중간에 있는 데이터를 늘려야 하는 상황이라면 해당 공간보다 뒤에 저장된 데이터들을 전부 뒤로 옮기고, 이동시킨 주소를 각 식별자에 다시 연결하는 작업을 해야한다. 
- 500개의 변수를 생성해서 모든 변수에 숫자 5를 할당할 때, 각 변수 공간마다 매번 숫자 5를 할당하는 대신 5를 별도의 공간에 한 번만 저장하고 해당 주소만 입력하는 것이 효율적이다.


> 이는 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위함이다. 효율적으로 데이터의 변환과 중복된 데이터를 처리하기 위해서는 **변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.**

## 4. 기본형 데이터와 참조형 데이터

### 불변값

> 변수와 상수를 구분 짓는 변경 가능성의 대상은 변수 영역 메모리인 반면 **불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터 영역의 메모리이다.**

**👉🏻 기본형 데이터인 Number, String, Boolean, null, undefined, Symbol은 모두 불변값이다.**

```javascript
var a = 'abc';
a = a + 'def';
```
![](https://velog.velcdn.com/images/skdbsqls/post/3fe0d4e8-6e48-4acd-b7d8-425c20e7f3cd/image.png)

이처럼 변수 a에 문자열 'abc'를 할당했다가 뒤에 'def'을 추가하면 기존의 'abc'가 'abcdef'로 바뀌는 것이 아니라 **새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장**한다. 또한 기존 @5004 데이터는 자신의 주소를 저장하는 변수가 하나도 없게 되면 가비지 컬렉터의 수거 대상이 된다. 'abc'와 'abcdef'는 완전히 별개의 데이터이며 다른 값으로 변경할 수 없다.

> **변경은 새로 만드는 동작을 통해서만 이루어지며, 이것이 바로 불변값의 성질이다.** 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

### 가변값

```javascript
var obj1 = {
  a: 1,
  b: 'bbb',
};
```
![](https://velog.velcdn.com/images/skdbsqls/post/bb98eaab-89f3-402d-b716-c02f743a711c/image.png)

참조형 데이터는 기본형 데이터와 다르게 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다. 객체가 별도로 할애한 영역은 '변수 영역'으로 '데이터 영역'은 기존의 메모리 공간을 그대로 활용하고 있다.
**데이터 영역에 저장된 값은 모두 불변값이나 변수에는 다른 값을 얼마든지 대입할 수 있다. 바로 이 부분 때문에 흔히 참조형 데이터는 불변하지 않다, 즉 가변값이라고 한다.**

```javascript
var obj1 = {
  a: 1,
  b: 'bbb',
};
obj1.a = 2;
```
![](https://velog.velcdn.com/images/skdbsqls/post/70a21671-d333-409b-b11f-5fb844c6448c/image.png)

obj1의 a 프로퍼티에 숫자 2를 재할당 하고자 할 때, 데이터 영역에서 숫자 2를 검색한 결과가 없으므로 빈 공간인 @5005에 2를 저장하고 이 주소를 @7103에 저장한다. 재할당 이후로 obj1이 바라보고 있는 주소는 @5001로 변하지 않는다. 즉 새로운 객체가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐 것이다.

### 변수 복사 비교
```javascript
var a = 10;
var b = a;

var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;
```
![](https://velog.velcdn.com/images/skdbsqls/post/9ef37e34-734f-415e-b93d-135bc61fd1d9/image.png)

변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다. 하지만 데이터 할당 과정에서 차이가 있기 때문에 변수 복수 이후의 동작에는 큰 차이가 발생한다.

- **변수 복사 이후 객체의 프로퍼티를 변경했을 때**

  ```javascript
  let a = 10;
  let b = a;
  b = 15;

  console.log(a); // 10
  console.log(b); // 15

  let obj1 = { c: 10, d: "ddd" };
  let obj2 = obj1;
  obj2.c = 20;

  console.log(obj1); // { c: 20, d: 'ddd' }
  console.log(obj2); // { c: 20, d: 'ddd' }
  ```

  ![](https://velog.velcdn.com/images/skdbsqls/post/f7c3c778-af55-43df-ab65-80b0c28f6ee5/image.png)

  기본형 데이터를 복사한 변수 b의 값을 바꾼 결과 @1002의 값이 달라진 반면, 참조형 데이터를 복사한 변수 obj2의 프로퍼티의 값을 바꾼 결과 @1004의 값은 달라지지 않았다.
  > **즉, 변수 a와 b는 서로 다른 주소를 바라보게 되었으나, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있다. 이것이 바로 기본형과 참조형 데이터의 가장 큰 차이점이다.**

- **변수 복사 이후 객체 자체를 변경했을 때**

  ```javascript
  let a = 10;
  let b = a;
  b = 15;

  console.log(a); // 10
  console.log(b); // 15

  let obj1 = { c: 10, d: "ddd" };
  let obj2 = obj1;
  obj2 = { c: 20, d: "ddd" };

  console.log(obj1); // { c: 10, d: 'ddd' }
  console.log(obj2); // { c: 20, d: 'ddd' }
  ```

  ![](https://velog.velcdn.com/images/skdbsqls/post/a22addb2-4c7d-4754-820a-cb79ee4a5690/image.png)

  이번에는 b의 경우와 마찬가지로 obj2에 새로운 객체를 할당함으로써 값을 직접 변경한다면 메모리의 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장할 것이다.
> **  즉, 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.**
